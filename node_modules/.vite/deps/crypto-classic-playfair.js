import {
  __commonJS
} from "./chunk-LNEMQRCO.js";

// node_modules/crypto-classic-utils/utils.js
var require_utils = __commonJS({
  "node_modules/crypto-classic-utils/utils.js"(exports, module) {
    module.exports = {
      // Remove whitespace from beginning and end of text
      Trim: function(s) {
        while (s.length && " 	\r\n".indexOf(s.charAt(0)) >= 0) {
          s = s.slice(1, s.length);
        }
        while (s.length && " 	\r\n".indexOf(s.charAt(s.length - 1)) >= 0) {
          s = s.slice(0, s.length - 1);
        }
        return s;
      },
      // Exchange characters in F for ones in T for the string S.  If T is not
      // specified or not long enough, the characters are removed.
      // "aaabbbC!!" = Tr("AaaBbbCcc", "ABc", "ab!")
      // "Test thing" = Tr("Test\n thing", "\r\n")
      Tr: function(s, f, t) {
        var o = "";
        if (typeof t != "string") {
          t = "";
        }
        for (var i2 = 0; i2 < s.length; i2++) {
          var c = s.charAt(i2);
          var idx = f.indexOf(c);
          if (idx >= 0) {
            if (idx < t.length) {
              o += t.charAt(idx);
            }
          } else {
            o += c;
          }
        }
        return o;
      },
      // Insert CR and LF characters into e, based on the position of those
      // characters in T.
      // If T = "ab\ncd" and E = "zyxw", the result will be "zy\nxw"
      InsertCRLF: function(t, e) {
        var o = "", i2, j2;
        for (i2 = 0, j2 = 0; i2 < t.length; i2++) {
          if ("\r\n".indexOf(t.charAt(i2)) >= 0) {
            o += t.charAt(i2);
          } else {
            o += e.charAt(j2++);
          }
        }
        return o;
      },
      // Returns an alphabet with a key in front.
      // Passing the key of "Four. Score! And Seven Days Ago?"
      // will return  "FOURSCEANDVYGBHIJKLMPQTWXZ"
      // key = the letters to include in the beginning
      // alphaet = the alphabet to use (if not A-Z)
      MakeKeyedAlphabet: function(key, alphabet) {
        var out = "";
        if (typeof alphabet != "string")
          alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
        else
          alphabet = alphabet.toUpperCase();
        if (typeof key != "string")
          return alphabet;
        key = key.toUpperCase() + alphabet;
        for (var i2 = 0; i2 < key.length; i2++) {
          if (out.indexOf(key.charAt(i2)) < 0 && alphabet.indexOf(key.charAt(i2)) >= 0) {
            out += key.charAt(i2);
          }
        }
        return out;
      },
      // Make any string contain just alpha characters
      OnlyAlpha: function(str) {
        var out = "";
        for (i = 0; i < str.length; i++) {
          var b = str.charAt(i);
          if (b.toUpperCase() >= "A" && b.toUpperCase() <= "Z") {
            out += b;
          }
        }
        return out;
      },
      // Change a string into valid HTML text
      HTMLEscape: function(str) {
        var out = "";
        for (var i2 = 0; i2 < str.length; i2++) {
          var c = str.charAt(i2);
          if (c == "&")
            c = "&amp;";
          if (c == ">")
            c = "&gt;";
          if (c == "<")
            c = "&lt;";
          if (c == "\n")
            c = "<br>\n";
          out += c;
        }
        return out;
      },
      // Pass it a textarea object, get it resized automagically
      ResizeTextArea: function(obj) {
        var s = obj.value + "\n";
        var newlines = 0;
        var max_chars = 0;
        var i2, chars = 0, wide = 0;
        var obj_max_cols = 100, obj_min_cols = 40, obj_max_rows = 15;
        var scrollbar_width = 2;
        for (i2 = 0; i2 < s.length; i2++) {
          var c = s.charAt(i2);
          if (c == "\n") {
            if (max_chars < chars)
              max_chars = chars;
            chars = 0;
            newlines++;
          } else {
            if (chars == obj_max_cols - scrollbar_width) {
              max_chars = chars;
              j = i2;
              var c2 = s.charAt(j);
              while (c2 != "\n" && c2 != " " && c2 != "	" && j > 0) {
                j--;
                c2 = s.charAt(j);
              }
              if (c2 != "\n" && j > 0) {
                newlines++;
                chars = 0;
                i2 = j;
              } else {
                wide = 1;
              }
            } else {
              chars++;
            }
          }
          if (obj_max_rows <= newlines + wide + 1 && obj_max_cols <= max_chars + scrollbar_width) {
            obj.rows = obj_max_rows;
            obj.cols = obj_max_cols;
            return;
          }
        }
        obj.rows = Math.min(obj_max_rows, newlines + wide + 1);
        obj.cols = Math.min(Math.max(obj_min_cols, max_chars + scrollbar_width), obj_max_cols);
      },
      Reverse_String: function(s) {
        var o = "", i2 = s.length;
        while (i2--) {
          o += s.charAt(i2);
        }
        return o;
      },
      // Returns 1 if there was no change, 0 if it is not the same
      // Saves value in the element if it was changed, so subsequent calls
      // to this function will return 1 until it changes again.
      // Don't use this function like this:
      //   if (IsUnchanged(x) && IsUnchanged(y) && IsUnchanged(z)) { ... }
      // The logic code could short-circuit on X or Z (depending on how it
      // gets parsed) and will jump to the 'if' block without evaluating
      // all of the variables.  Use this instead:
      //   if (IsUnchanged(x) * IsUnchanged(y) * IsUnchanged(z)) { ... }
      //   if (IsUnchanged(x) + IsUnchanged(y) + IsUnchanged(z) == 3) { ... }
      IsUnchanged: function(e) {
        var v;
        if (e.type == "checkbox") {
          v = e.checked.toString();
        } else {
          v = e.value;
        }
        if (v != e.getAttribute("_oldValue")) {
          e.setAttribute("_oldValue", v);
          return 0;
        }
        return 1;
      },
      // Makes a tableau out of a passed in key
      // Key should be 25 characters!
      HTMLTableau: function(key) {
        var out = "";
        for (var i2 = 0; i2 < 25; i2++) {
          if (i2 > 0 && i2 % 5 == 0) {
            out += "<br>\n";
          }
          if (i2 % 5) {
            out += " ";
          }
          out += key.charAt(i2);
        }
        return "<tt>" + out + "</tt>";
      },
      // Change multiple spaces into &nbsp; to preserve padding.
      SwapSpaces: function(in_str) {
        var out = "";
        var multi = 1;
        for (var i2 = 0; i2 < in_str.length; i2++) {
          var c = in_str.charAt(i2);
          if (c == " ") {
            if (multi) {
              out += "&nbsp;";
              multi = 0;
            } else {
              out += " ";
              multi = 1;
            }
          } else if (multi && (c == "\r" || c == "\n" || c == "	")) {
            out = out.slice(0, out.length - 1) + "&nbsp;" + c;
            multi = 0;
          } else {
            out += c;
            multi = 0;
          }
        }
        if (out.charAt(out.length - 1) == " ") {
          out = out.slice(0, out.length - 1) + "&nbsp;";
        }
        return out;
      },
      // Return a letter frequency count
      // Caches information for faster retrieval by multiple functions
      // and faster calculation when text is being typed into the forms.
      LetterFrequency: function(text) {
        var LetterFrequency_LastText = "";
        var LetterFrequency_LastFreq = new Array();
        var n = new Array();
        var i2 = 0, j2;
        if (LetterFrequency_LastText == text) {
          return LetterFrequency_LastFreq;
        }
        if (text.slice(0, LetterFrequency_LastText.length) == LetterFrequency_LastText) {
          n = LetterFrequency_LastFreq;
          i2 = LetterFrequency_LastText.length;
        }
        for (j2 = text.length; i2 < j2; i2++) {
          var c = text.charAt(i2);
          if (!n[c]) {
            n[c] = 1;
          } else {
            n[c]++;
          }
        }
        LetterFrequency_LastText = text;
        LetterFrequency_LastFreq = n;
        return n;
      },
      // Returns true if the number passed in is prime
      // 2 is considered the first prime.
      PrimeList: [
        2,
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
        61,
        67,
        71,
        73,
        79,
        83,
        89,
        97
      ],
      IsPrime: function(n) {
        if (n < 2 || n != Math.floor(n)) {
          return false;
        }
        for (var i2 = 0; i2 < this.PrimeList.length; i2++) {
          if (this.PrimeList[i2] == n) {
            return true;
          }
          if (this.PrimeList[i2] > n) {
            return false;
          }
        }
        var m = Math.floor(Math.sqrt(n));
        var m2 = this.PrimeList[this.PrimeList.length - 1];
        if (m2 < m) {
          while (m2 <= m) {
            m2 += 2;
            if (this.IsPrime(m2)) {
              this.PrimeList[this.PrimeList.length] = m2;
            }
          }
        }
        for (var i2 = 0; this.PrimeList[i2] <= m; i2++) {
          var d = n / this.PrimeList[i2];
          if (d == Math.floor(d)) {
            return false;
          }
        }
        return true;
      },
      // Returns the prime factors of a number as an array
      // I don't work with negative numbers or zero or non-integers.
      GetFactors: function(n) {
        var factors = new Array();
        if (n < 1 || n != Math.floor(n)) {
          return factors;
        }
        if (IsPrime(n)) {
          factors[factors.length] = n;
          return factors;
        }
        var index = 0;
        var skipCheck = 0;
        while (skipCheck || !IsPrime(n)) {
          var d = n / PrimeList[index];
          if (d == Math.floor(d)) {
            if (PrimeList[index] != factors[factors.length - 1]) {
              factors[factors.length] = PrimeList[index];
            }
            n = d;
            skipCheck = 0;
          } else {
            index++;
            skipCheck = 1;
          }
        }
        if (n != factors[factors.length - 1]) {
          factors[factors.length] = n;
        }
        return factors;
      },
      // Returns true if the numbers we are comparing are coprime.
      // Returns false if either one is a non-integer or zero.
      // Returns true if either is one.
      IsCoprime: function(a, b) {
        var CoprimeCache = new Array();
        var CoprimeCacheNum = new Array();
        var a_factors = false, b_factors = false;
        if (a < 1 || b < 1 || a != Math.floor(a) || b != Math.floor(b)) {
          return false;
        }
        if (a == 1 || b == 1) {
          return true;
        }
        for (var i2 = 0; i2 < CoprimeCacheNum.length; i2++) {
          if (CoprimeCacheNum[i2] == a) {
            a_factors = CoprimeCache[i2];
          }
          if (CoprimeCacheNum[i2] == b) {
            b_factors = CoprimeCache[i2];
          }
        }
        if (!a_factors) {
          a_factors = this.GetFactors(a);
        }
        if (!b_factors) {
          b_factors = this.GetFactors(b);
        }
        CoprimeCache = [a_factors, b_factors];
        CoprimeCacheNum = [a, b];
        var a_idx = 0;
        var b_idx = 0;
        while (a_idx < a_factors.length && b_idx < b_factors.length) {
          if (a_factors[a_idx] < b_factors[b_idx]) {
            a_idx++;
          } else if (a_factors[a_idx] > b_factors[b_idx]) {
            b_idx++;
          } else {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/crypto-classic-playfair/lib/playfair.js
var require_playfair = __commonJS({
  "node_modules/crypto-classic-playfair/lib/playfair.js"(exports, module) {
    module.exports = function Playfair(encdec, text, skip, skipto, key, flags) {
      var CipherUtils = require_utils();
      var enc, out, bet, otemp, c;
      if (typeof skip != "string" || skip.length != 1 || skip.toUpperCase() < "A" || skip.toUpperCase() > "Z")
        skip = "J";
      skip = skip.toUpperCase();
      if (typeof skipto != "string" || skipto.length != 1 || skipto.toUpperCase() < "A" || skipto.toUpperCase() > "Z")
        skipto = "I";
      skipto = skipto.toUpperCase();
      if (skip == skipto) {
        skipto = String.fromCharCode(skip.charCodeAt(0) + 1);
        if (skipto > "Z")
          skipto = "A";
      }
      if (typeof key != "string")
        key = "";
      key = CipherUtils.MakeKeyedAlphabet(skip + key);
      key = key.slice(1, key.length);
      enc = "";
      out = "";
      bet = "";
      for (var i2 = 0; i2 < text.length; i2++) {
        c = text.charAt(i2).toUpperCase();
        if (c == skip)
          c = skipto;
        if (key.indexOf(c) >= 0) {
          if (text.charAt(i2) != text.charAt(i2).toUpperCase())
            enc += c.toLowerCase();
          else
            enc += c;
          if (enc.length == 2) {
            otemp = Playfair_Lookup(encdec, enc, key, flags);
            out += otemp.charAt(0) + bet + otemp.charAt(1);
            bet = "";
            enc = "";
          }
        } else {
          if (enc.length > 0) {
            bet += text.charAt(i2);
          } else {
            out += text.charAt(i2);
          }
        }
      }
      if (enc.length > 0) {
        otemp = Playfair_Lookup(encdec, enc + "X", key);
        out += otemp.charAt(0) + bet + otemp.charAt(1);
      }
      return out;
    };
    function Playfair_Lookup(encdec, chars, key, flags) {
      var t1, t2, u1, u2, r1, r2, c1, c2;
      t1 = chars.charAt(0);
      t2 = chars.charAt(1);
      u1 = 0;
      if (t1 != t1.toUpperCase()) {
        t1 = t1.toUpperCase();
        u1 = 1;
      }
      u2 = 0;
      if (t2 != t2.toUpperCase()) {
        t2 = t2.toUpperCase();
        u2 = 1;
      }
      c1 = key.indexOf(t1);
      r1 = Math.floor(c1 / 5);
      c1 = c1 % 5;
      c2 = key.indexOf(t2);
      r2 = Math.floor(c2 / 5);
      c2 = c2 % 5;
      if (r1 == r2 && c1 == c2) {
        if ((flags & 1) == 0) {
          r1 += encdec;
          r2 += encdec;
          c1 += encdec;
          c2 += encdec;
        }
      } else if (r1 == r2) {
        c1 += encdec;
        c2 += encdec;
      } else if (c1 == c2) {
        r1 += encdec;
        r2 += encdec;
      } else {
        var a;
        a = c1;
        c1 = c2;
        c2 = a;
      }
      r1 = (r1 + 5) % 5;
      r2 = (r2 + 5) % 5;
      c1 = (c1 + 5) % 5;
      c2 = (c2 + 5) % 5;
      t1 = key.charAt(r1 * 5 + c1);
      t2 = key.charAt(r2 * 5 + c2);
      if (u1)
        t1 = t1.toLowerCase();
      if (u2)
        t2 = t2.toLowerCase();
      return t1 + t2;
    }
  }
});

// node_modules/crypto-classic-playfair/playfair.js
var require_playfair2 = __commonJS({
  "node_modules/crypto-classic-playfair/playfair.js"(exports, module) {
    var PlayFair = require_playfair();
    module.exports = {
      encipher: function(pt, key) {
        var digraphs = [];
        for (var i2 = 0; i2 < pt.length; i2 += 2) {
          var digraph = pt.slice(i2, i2 + 2);
          if (digraph.charAt(1) === "") {
            digraph = digraph.charAt(0) + "z";
          } else if (digraph.charAt(0) == digraph.charAt(1)) {
            digraph = digraph.charAt(0) + "x";
            i2 -= 1;
          }
          digraphs.push(digraph);
        }
        if (digraphs.length > 0) {
          return PlayFair(1, digraphs.join(" "), "J", "I", key);
        }
      },
      decipher: function(ct, key) {
        return PlayFair(-1, ct, "J", "I", key);
      }
    };
  }
});
export default require_playfair2();
//# sourceMappingURL=crypto-classic-playfair.js.map
