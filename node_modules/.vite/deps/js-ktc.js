import {
  __commonJS,
  __publicField
} from "./chunk-LNEMQRCO.js";

// node_modules/js-ktc/cipher.min.js
var require_cipher_min = __commonJS({
  "node_modules/js-ktc/cipher.min.js"(exports, module) {
    var Cipher = class {
      constructor(secret, props = { alpha: "ABCDEFGHIJKLMNOPQRSTUVWXYZ", toUpper: true, stripCharacters: true, addSpaces: true, stripSpaces: true }) {
        __publicField(this, "_distinct", (val) => val.split("").filter((item, i, self) => self.indexOf(item) === i).join(""));
        __publicField(this, "_max", (i, max) => i > max ? max : i);
        __publicField(this, "_flatIndex", (i) => Math.floor(i / this.height) + i % this.height * this.width);
        __publicField(this, "_addSpaces", (s) => this.props.addSpaces ? s.replace(/.{5}/g, "$& ") : s);
        __publicField(this, "_crypt", (s, alphaA, alphaB) => this._addSpaces(s.split("").map((lttr) => alphaA[alphaB.indexOf(lttr)]).join("")));
        __publicField(this, "_convertCase", (s) => this.props.toUpper ? s.toUpperCase() : s);
        __publicField(this, "_stripCharacters", (s) => this.props.stripCharacters ? s.replace(/[^a-zA-Z]/g, "") : s);
        __publicField(this, "_stripSpaces", (s) => this.props.stripSpaces ? s.replace(/ /g, "") : s);
        __publicField(this, "_parse", (s) => this._stripCharacters(this._stripSpaces(this._convertCase(s))));
        __publicField(this, "encrypt", (s) => this._crypt(this._parse(s), this.encryptedAlpha, this.alpha));
        __publicField(this, "decrypt", (s) => this._crypt(s, this.alpha, this.encryptedAlpha));
        this.props = props;
        this.alpha = props.alpha;
        this.trans = [];
        this.key = this._parse(secret);
        this.key = this._distinct(this.key);
        this.cipher = this.key.split("");
        this.cipher = this.cipher.sort();
        this.width = this.cipher.length;
        this.height = Math.floor(this.alpha.length / this.cipher.length) + 1;
        var kAlpha = this.key + this.alpha;
        kAlpha = this._distinct(kAlpha);
        const padding = Array(Math.abs(this.width * this.height - kAlpha.length) + 1).join(" ");
        this.kAlpha = kAlpha + padding;
        this.cipher.forEach((_, i) => {
          let letter = this.kAlpha[i];
          let cipherIndex = this.cipher.indexOf(letter);
          this.trans[cipherIndex] = cipherIndex - i;
        });
        this.encryptedAlpha = this._parse(this.kAlpha.split("").map((_, i) => {
          let kAlphaIndex = this._max(this._flatIndex(i) - this.trans[this._flatIndex(i) % this.width], this.kAlpha.length);
          return this.kAlpha[kAlphaIndex];
        }).join(""));
      }
    };
    module.exports = Cipher;
  }
});
export default require_cipher_min();
//# sourceMappingURL=js-ktc.js.map
